import{Q as l,V as c,n as a,C as m,M as g,b as f,e as r,E as d,c as y,S as w,d as p,N as h}from"./index-DbWvsKsa.js";import{f as M}from"./index-DbWvsKsa.js";class S{scene;camera;remotePlayers=new Map;syncedObjects=new Map;localPlayerState={position:new c,rotation:new l,lastSent:0};syncRate=20;interpolationTime=100;enabled=!1;constructor(e,t){this.scene=e,this.camera=t,this.setupNetworkListeners(),console.log("ðŸ”„ Multiplayer Sync initialized")}setupNetworkListeners(){}enable(){this.enabled=!0,console.log("âœ… Multiplayer sync enabled")}disable(){this.enabled=!1,console.log("âŒ Multiplayer sync disabled")}update(e){this.enabled&&(this.syncLocalPlayer(e),this.interpolateRemotePlayers(e),this.syncObjects(e))}syncLocalPlayer(e){const t=Date.now();if(t-this.localPlayerState.lastSent>=1e3/this.syncRate){const n=this.camera.position.clone(),s=this.camera.quaternion.clone();a.syncPlayerState({x:n.x,y:n.y,z:n.z},{x:s.x,y:s.y,z:s.z,w:s.w},!1),this.localPlayerState.position.copy(n),this.localPlayerState.rotation.copy(s),this.localPlayerState.lastSent=t}}interpolateRemotePlayers(e){const t=Date.now();this.remotePlayers.forEach(o=>{const n=t-o.lastUpdate,s=Math.min(n/this.interpolationTime,1);o.mesh.position.lerp(o.targetPosition,s),o.mesh.quaternion.slerp(o.targetRotation,s),n>this.interpolationTime&&o.mesh.position.add(o.velocity.clone().multiplyScalar(e))})}syncObjects(e){}addRemotePlayer(e,t){if(this.remotePlayers.has(e)){console.warn(`âš ï¸ Player ${e} already exists`);return}const o=new m(.3,1.4,4,8),n=new g({color:4474111,roughness:.7,metalness:.3}),s=new f(o,n);s.position.set(t.position.x,t.position.y,t.position.z),s.name=`Player_${e}`,this.scene.add(s);const i=this.createNameTag(t.name||e);i.position.y=2,s.add(i),this.remotePlayers.set(e,{mesh:s,targetPosition:new c(t.position.x,t.position.y,t.position.z),targetRotation:new l(t.rotation.x,t.rotation.y,t.rotation.z,t.rotation.w),lastUpdate:Date.now(),velocity:new c}),console.log(`ðŸ‘¤ Remote player added: ${e}`),r.emit(d.TOOL_ACTIVATED,{toolType:`Multiplayer:PlayerAdded:${e}`})}updateRemotePlayer(e,t){const o=this.remotePlayers.get(e);if(!o){this.addRemotePlayer(e,t);return}const n=Date.now(),s=(n-o.lastUpdate)/1e3,i=new c(t.position.x,t.position.y,t.position.z);s>0&&(o.velocity.subVectors(i,o.targetPosition),o.velocity.divideScalar(s)),o.targetPosition.copy(i),o.targetRotation.set(t.rotation.x,t.rotation.y,t.rotation.z,t.rotation.w),o.lastUpdate=n}removeRemotePlayer(e){const t=this.remotePlayers.get(e);t&&(this.scene.remove(t.mesh),t.mesh.geometry.dispose(),t.mesh.material.dispose(),this.remotePlayers.delete(e),console.log(`ðŸ‘¤ Remote player removed: ${e}`),r.emit(d.TOOL_DEACTIVATED,{toolType:`Multiplayer:PlayerRemoved:${e}`}))}createNameTag(e){const t=document.createElement("canvas"),o=t.getContext("2d");t.width=256,t.height=64,o.fillStyle="rgba(0, 0, 0, 0.7)",o.fillRect(0,0,t.width,t.height),o.font="bold 32px Arial",o.fillStyle="#ffffff",o.textAlign="center",o.textBaseline="middle",o.fillText(e,t.width/2,t.height/2);const n=new y(t),s=new w({map:n}),i=new p(s);return i.scale.set(1,.25,1),i}registerObject(e,t,o){this.syncedObjects.set(e,{object:t,ownerId:o,lastUpdate:Date.now()}),console.log(`ðŸ”„ Object registered for sync: ${e}`)}unregisterObject(e){this.syncedObjects.delete(e),console.log(`ðŸ”„ Object unregistered: ${e}`)}syncObjectTransform(e,t,o,n){const s=this.syncedObjects.get(e);s&&(s.object.position.copy(t),s.object.quaternion.copy(o),s.object.scale.copy(n),s.lastUpdate=Date.now())}setSyncRate(e){this.syncRate=e,a.setSyncRate(e),console.log(`ðŸ”„ Sync rate: ${e}Hz`)}setInterpolationTime(e){this.interpolationTime=e,console.log(`ðŸ”„ Interpolation time: ${e}ms`)}getRemotePlayers(){return this.remotePlayers}clearAll(){this.remotePlayers.forEach((e,t)=>{this.removeRemotePlayer(t)}),this.syncedObjects.clear(),console.log("ðŸ§¹ Multiplayer sync cleared")}getStats(){return{remotePlayers:this.remotePlayers.size,syncedObjects:this.syncedObjects.size,syncRate:this.syncRate,interpolationTime:this.interpolationTime}}printStats(){const e=this.getStats();console.log("ðŸ“Š Multiplayer Sync Stats:"),console.log(`   Remote Players: ${e.remotePlayers}`),console.log(`   Synced Objects: ${e.syncedObjects}`),console.log(`   Sync Rate: ${e.syncRate}Hz`),console.log(`   Interpolation: ${e.interpolationTime}ms`)}}class T{peerConnections=new Map;localStream=null;audioContext=null;gainNode=null;isEnabled=!1;isMuted=!1;isPushToTalk=!0;isTalking=!1;audioConstraints={audio:{echoCancellation:!0,noiseSuppression:!0,autoGainControl:!0,sampleRate:48e3},video:!1};constructor(){this.setupAudioContext(),this.setupNetworkListeners(),console.log("ðŸŽ¤ VoIP System initialized")}setupNetworkListeners(){r.on(h.MESSAGE_RECEIVED,e=>{const{from:t,message:o}=e;if(!(!o||typeof o!="object"))switch(o.type){case"webrtc_offer":o.offer&&this.handleOffer(t,o.offer);break;case"webrtc_answer":o.answer&&this.handleAnswer(t,o.answer);break;case"ice_candidate":o.candidate&&this.handleIceCandidate(t,o.candidate);break}}),r.on(h.PLAYER_LEFT,e=>{this.disconnectPeer(e.playerId)})}setupAudioContext(){try{this.audioContext=new(window.AudioContext||window.webkitAudioContext),this.gainNode=this.audioContext.createGain(),this.gainNode.connect(this.audioContext.destination),console.log("âœ… Audio context created")}catch(e){console.error("âŒ Failed to create audio context:",e)}}async enable(){if(this.isEnabled){console.warn("âš ï¸ VoIP already enabled");return}try{this.localStream=await navigator.mediaDevices.getUserMedia(this.audioConstraints),console.log("âœ… Microphone access granted"),this.isEnabled=!0,this.connectToExistingPlayers(),console.log("ðŸŽ¤ VoIP enabled")}catch(e){throw console.error("âŒ Failed to enable VoIP:",e),e}}disable(){if(!this.isEnabled){console.warn("âš ï¸ VoIP already disabled");return}this.localStream&&(this.localStream.getTracks().forEach(e=>e.stop()),this.localStream=null),this.peerConnections.forEach((e,t)=>{this.disconnectPeer(t)}),this.isEnabled=!1,console.log("ðŸŽ¤ VoIP disabled")}connectToExistingPlayers(){a.getPlayers().forEach((t,o)=>{o!==a.getPlayerId()&&this.connectToPeer(o)})}async connectToPeer(e){if(!this.isEnabled||!this.localStream){console.warn("âš ï¸ VoIP not enabled");return}try{const t=new RTCPeerConnection({iceServers:[{urls:"stun:stun.l.google.com:19302"},{urls:"stun:stun1.l.google.com:19302"}]});this.localStream.getTracks().forEach(n=>{t.addTrack(n,this.localStream)}),t.ontrack=n=>{this.handleRemoteStream(e,n.streams[0])},t.onicecandidate=n=>{n.candidate&&a.sendMessage(e,{type:"ice_candidate",candidate:n.candidate})},t.onconnectionstatechange=()=>{console.log(`ðŸ”Œ Connection state (${e}):`,t.connectionState),(t.connectionState==="disconnected"||t.connectionState==="failed")&&this.disconnectPeer(e)};const o=await t.createOffer();await t.setLocalDescription(o),a.sendMessage(e,{type:"webrtc_offer",offer:o}),this.peerConnections.set(e,t),console.log(`ðŸŽ¤ Connected to peer: ${e}`)}catch(t){console.error(`âŒ Failed to connect to peer ${e}:`,t)}}disconnectPeer(e){const t=this.peerConnections.get(e);t&&(t.close(),this.peerConnections.delete(e),console.log(`ðŸŽ¤ Disconnected from peer: ${e}`))}handleRemoteStream(e,t){console.log(`ðŸ”Š Receiving audio from: ${e}`);const o=new Audio;o.srcObject=t,o.autoplay=!0,this.audioContext&&this.gainNode&&this.audioContext.createMediaStreamSource(t).connect(this.gainNode)}async handleOffer(e,t){if(!(!this.isEnabled||!this.localStream))try{const o=new RTCPeerConnection({iceServers:[{urls:"stun:stun.l.google.com:19302"}]});this.localStream.getTracks().forEach(s=>{o.addTrack(s,this.localStream)}),o.ontrack=s=>{this.handleRemoteStream(e,s.streams[0])},o.onicecandidate=s=>{s.candidate&&a.sendMessage(e,{type:"ice_candidate",candidate:s.candidate})},await o.setRemoteDescription(new RTCSessionDescription(t));const n=await o.createAnswer();await o.setLocalDescription(n),a.sendMessage(e,{type:"webrtc_answer",answer:n}),this.peerConnections.set(e,o),console.log(`ðŸŽ¤ Answered offer from: ${e}`)}catch(o){console.error(`âŒ Failed to handle offer from ${e}:`,o)}}async handleAnswer(e,t){const o=this.peerConnections.get(e);if(o)try{await o.setRemoteDescription(new RTCSessionDescription(t)),console.log(`ðŸŽ¤ Received answer from: ${e}`)}catch(n){console.error(`âŒ Failed to handle answer from ${e}:`,n)}}async handleIceCandidate(e,t){const o=this.peerConnections.get(e);if(o)try{await o.addIceCandidate(new RTCIceCandidate(t))}catch(n){console.error(`âŒ Failed to add ICE candidate from ${e}:`,n)}}setMuted(e){this.isMuted=e,this.localStream&&this.localStream.getAudioTracks().forEach(t=>{t.enabled=!e}),console.log(`ðŸŽ¤ ${e?"Muted":"Unmuted"}`)}toggleMute(){this.setMuted(!this.isMuted)}pushToTalkPress(){this.isPushToTalk&&!this.isTalking&&(this.isTalking=!0,this.setMuted(!1),console.log("ðŸŽ¤ Push to talk: ON"))}pushToTalkRelease(){this.isPushToTalk&&this.isTalking&&(this.isTalking=!1,this.setMuted(!0),console.log("ðŸŽ¤ Push to talk: OFF"))}setPushToTalk(e){this.isPushToTalk=e,e||this.setMuted(!1),console.log(`ðŸŽ¤ Push to talk: ${e?"enabled":"disabled"}`)}setVolume(e){this.gainNode&&(this.gainNode.gain.value=Math.max(0,Math.min(1,e)),console.log(`ðŸ”Š Volume: ${Math.round(e*100)}%`))}getIsEnabled(){return this.isEnabled}getIsMuted(){return this.isMuted}getStats(){return{enabled:this.isEnabled,muted:this.isMuted,pushToTalk:this.isPushToTalk,connections:this.peerConnections.size}}printStats(){const e=this.getStats();console.log("ðŸ“Š VoIP Stats:"),console.log(`   Enabled: ${e.enabled}`),console.log(`   Muted: ${e.muted}`),console.log(`   Push to Talk: ${e.pushToTalk}`),console.log(`   Active Connections: ${e.connections}`)}}export{S as MultiplayerSync,h as NetworkEventType,M as NetworkManager,T as VoIPSystem,a as networkManager};
