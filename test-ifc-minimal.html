<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>IFC Test - MINIMAL</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { 
      font-family: monospace; 
      background: #1e1e1e; 
      color: #e0e0e0;
      overflow: hidden;
    }
    #canvas { 
      width: 100vw; 
      height: 100vh; 
      display: block; 
    }
    #controls {
      position: fixed;
      top: 20px;
      left: 20px;
      background: rgba(0,0,0,0.8);
      padding: 20px;
      border-radius: 8px;
      z-index: 1000;
    }
    #log {
      position: fixed;
      bottom: 20px;
      left: 20px;
      right: 20px;
      background: rgba(0,0,0,0.9);
      padding: 15px;
      border-radius: 8px;
      max-height: 200px;
      overflow-y: auto;
      font-size: 12px;
      z-index: 1000;
    }
    .log-item {
      margin: 4px 0;
      padding: 4px 8px;
      border-radius: 4px;
    }
    .log-info { background: rgba(33, 150, 243, 0.2); }
    .log-success { background: rgba(76, 175, 80, 0.2); }
    .log-error { background: rgba(244, 67, 54, 0.2); }
    button {
      background: #2196f3;
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      margin-right: 10px;
    }
    button:hover { background: #1976d2; }
    input[type="file"] { margin-top: 10px; }
    #status {
      margin-top: 10px;
      padding: 10px;
      border-radius: 4px;
      background: rgba(255,255,255,0.05);
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  
  <div id="controls">
    <h3>üî¨ IFC Minimal Test</h3>
    <input type="file" id="fileInput" accept=".ifc" />
    <div id="status">
      <div>Scene: <span id="scene-status">‚è≥</span></div>
      <div>Loader: <span id="loader-status">‚è≥</span></div>
      <div>WASM: <span id="wasm-status">‚è≥</span></div>
    </div>
  </div>

  <div id="log"></div>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';
    import { IFCLoader as ThreeIFCLoader } from 'web-ifc-three';

    // Logger
    const log = (msg, type = 'info') => {
      console.log(msg);
      const logDiv = document.getElementById('log');
      const item = document.createElement('div');
      item.className = `log-item log-${type}`;
      item.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
      logDiv.appendChild(item);
      logDiv.scrollTop = logDiv.scrollHeight;
    };

    const updateStatus = (id, status) => {
      document.getElementById(id).textContent = status;
    };

    // 1. SETUP THREE.JS B√ÅSICO
    log('üöÄ Initializing Three.js...', 'info');
    
    const canvas = document.getElementById('canvas');
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x1e1e1e);
    
    const camera = new THREE.PerspectiveCamera(
      75,
      window.innerWidth / window.innerHeight,
      0.1,
      1000
    );
    camera.position.set(10, 10, 10);
    
    const renderer = new THREE.WebGLRenderer({ 
      canvas, 
      antialias: true 
    });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.shadowMap.enabled = true;
    
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    
    // Lights
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
    scene.add(ambientLight);
    
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(10, 20, 10);
    directionalLight.castShadow = true;
    scene.add(directionalLight);
    
    // Grid
    const gridHelper = new THREE.GridHelper(100, 100);
    scene.add(gridHelper);
    
    log('‚úÖ Three.js initialized', 'success');
    updateStatus('scene-status', '‚úÖ');
    
    // Animation loop
    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }
    animate();
    
    // Resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // 2. SETUP IFC LOADER
    log('üì¶ Initializing IFC Loader...', 'info');
    
    const ifcLoader = new ThreeIFCLoader();
    const wasmPath = `${import.meta.env.BASE_URL || '/'}wasm/`;
    
    log(`üîß WASM path: ${wasmPath}`, 'info');
    
    try {
      ifcLoader.ifcManager.setWasmPath(wasmPath);
      ifcLoader.ifcManager.useWebWorkers(false);
      
      // Force single-thread
      ifcLoader.ifcManager.applyWebIfcConfig({
        COORDINATE_TO_ORIGIN: true,
        USE_FAST_BOOLS: true,
      });
      
      log('‚úÖ IFC Loader configured (single-thread)', 'success');
      updateStatus('loader-status', '‚úÖ');
    } catch (error) {
      log(`‚ùå IFC Loader error: ${error.message}`, 'error');
      updateStatus('loader-status', '‚ùå');
    }

    // 3. FIT CAMERA TO MODEL
    function fitCameraToObject(object, camera, controls) {
      const box = new THREE.Box3().setFromObject(object);
      const size = box.getSize(new THREE.Vector3());
      const center = box.getCenter(new THREE.Vector3());
      
      const maxSize = Math.max(size.x, size.y, size.z);
      const fitHeightDistance = maxSize / (2 * Math.atan((Math.PI * camera.fov) / 360));
      const fitWidthDistance = fitHeightDistance / camera.aspect;
      const distance = Math.max(fitHeightDistance, fitWidthDistance) * 1.5;
      
      const direction = controls.target.clone()
        .sub(camera.position)
        .normalize()
        .multiplyScalar(distance);
      
      camera.position.copy(center).sub(direction);
      camera.near = distance / 100;
      camera.far = distance * 100;
      camera.updateProjectionMatrix();
      
      controls.target.copy(center);
      controls.update();
      
      log(`üìê Camera fitted - Center: ${center.toArray().map(v => v.toFixed(2))}`, 'info');
    }

    // 4. LOAD IFC FILE
    document.getElementById('fileInput').addEventListener('change', async (e) => {
      const file = e.target.files[0];
      if (!file) return;
      
      log(`üìÇ File selected: ${file.name} (${(file.size / 1024 / 1024).toFixed(2)} MB)`, 'info');
      updateStatus('wasm-status', '‚è≥ Loading...');
      
      const url = URL.createObjectURL(file);
      
      try {
        log('üîÑ Starting IFC parse...', 'info');
        
        const model = await ifcLoader.loadAsync(
          url,
          (event) => {
            const progress = (event.loaded / event.total) * 100;
            log(`üìä Progress: ${progress.toFixed(0)}%`, 'info');
          }
        );
        
        log('‚úÖ IFC parsed successfully!', 'success');
        updateStatus('wasm-status', '‚úÖ');
        
        // Add to scene
        scene.add(model);
        log(`‚úÖ Model added to scene (${model.children.length} children)`, 'success');
        
        // Fit camera
        fitCameraToObject(model, camera, controls);
        log('‚úÖ Camera fitted to model', 'success');
        
        // Clean up
        URL.revokeObjectURL(url);
        
        log('üéâ IFC LOAD COMPLETE!', 'success');
        
      } catch (error) {
        log(`‚ùå LOAD FAILED: ${error.message}`, 'error');
        log(`‚ùå Stack: ${error.stack}`, 'error');
        updateStatus('wasm-status', '‚ùå');
        URL.revokeObjectURL(url);
      }
    });

    log('‚úÖ Test ready! Select an IFC file to start.', 'success');
    
    // Expose for debugging
    window.scene = scene;
    window.camera = camera;
    window.renderer = renderer;
    window.ifcLoader = ifcLoader;
  </script>
</body>
</html>
